package home_work_1;

//2. Изучить приоритетность операторов по таблице. Сначала посчитать результаты всех ниже приведённых примеров устно,
//   а потом проверить в IDE (в случае ошибок свериться с таблицей приоритетов, повторять просчёт примеров до полного соответствия).
//   Результатом МОЖЕТ БЫТЬ ОШИБКА компиляции, может быть ошибка выполнения программы или корректный результат.
//   Все значения в этих переменных должны быть записаны в int и boolean переменные. Напротив каждой строчки нужно написать комментарий с результатом
//   и объяснением почему вы получили такой результат.
//        2.0 ВНИМАНИЕ --8 значит что вам нужно создать переменную, например а, и проинициализировать её 8,
//        а дальше её использовать как --а. Данная переменная во всех выражениях должна равняться 8;
//        2.1 5 + 2 / 8
//        2.2 (5 + 2) / 8
//        2.3 (5 + 2++) / 8
//        2.4 (5 + 2++) / --8
//        2.5 (5 * 2 >> 2++) / --8
//        2.6 (5 + 7 > 20 ? 68 : 22 * 2 >> 2++) / --8
//        2.7 (5 + 7 > 20 ? 68 >= 68 : 22 * 2 >> 2++) / --8
//        2.8 6 - 2 > 3 && 12 * 12 <= 119
//        2.9 true && false

public class TaskTwo {
    public static void main(String[] args) {
        int a, b, c, d, e, f, g, resInt;
        boolean aBool, bBool, resBool;


//      2.1 5 + 2 / 8
        a = 5; b = 2; c = 8;
        resInt = a + b / c;   // 5 + 0 = 5  |  В начале выполняется операция деления 2 / 8, и так как обе переменные типа int,
                              // то результат будет не 0,25 а 0, а дальше просто прибавляется 5.

//      2.2 (5 + 2) / 8
        resInt = (a + b) / c; // 7 / 8 = 0  |  Здесь уже первая операция выполняется в скобках, и дальше мы 7 делим на 8 и получаем 0,
                              // по той же причине, которую я описал выше.

//      2.3 (5 + 2++) / 8
        resInt = (a + b++) / c; // (5 + 2) / 8 = 0  |  Здесь тоже первая операция выполняется в скобках, и там в начале мы используем значение переменной b, то есть 2,
                                // складываем с 5 и получаем 7, потому что здесь используется постфиксный инкремент, а дальше мы 7 делим на 8 и получаем 0,
                                // как и в предыдущем примере.

//      2.4 (5 + 2++) / --8
        b = 2;
        resInt = (a + b++) / --c; // (5 + 2) / 7 = 1 в скобках получается то же самое, что и в предыдущем примере, а вот переменная " c " в начале декрементируется на еденицу
                                  // а затем, мы 7 делим на 7 и получаем 1

//      2.5 (5 * 2 >> 2++) / --8
        b = 2; c = 8;
        resInt = (a * b >> b++) / --c; // 10 -> 2 / 7 = 0  |  В начале выполняется умножение 2 * 5 = 10, затем выполняется побитовая операция смещения вправо на 2 -
                                       // 00001010 -> 00000010, то есть в скобках мы получаем 2, и после этого уже переменная b становится равна 3, но нам это уже не важно,
                                       // а затем как и в предыдущем примере переменная " с " уменьшается на 1 и дальше, 2 / 7 = 0

//      2.6 (5 + 7 > 20 ? 68 : 22 * 2 >> 2++) / --8          // используется тернарный оператор
        a = 5; b = 2; c = 8; d = 7; e = 20; f = 68; g = 22;  // 11 / 7 = 1  |  resBool у нас получается false, потому что 12 < 20, поэтому выполняется выражение стоящее после оператора " : ",
        resBool = a + d > e;                                 // дальше 22 * 2 = 44, и 44 сдвигаем на 2 вправо и получаем 11: 00101100 -> 00001011, дальше уже переменная b становится равна 3, но нам это уже не важно,
        resInt = (resBool ? f : g * b >> b++) / --c;         // а затем как и в предыдущем примере переменная " с " уменьшается на 1 и дальше, 11 / 7 = 1

//      2.7 (5 + 7 > 20 ? 68 >= 68 : 22 * 2 >> 2++) / --8
        a = 5; b = 2; c = 8; d = 7; e = 20; f = 68; g = 22;
        resBool = a + d > e;
//      resInt = (resBool ? f >= f : g * b >> b++) / --c;  Ошибка компиляции, поскольку в скобках должно стоять какое - либо число, но в данном случаем, если бы условие
//                                                         в тернарном операторе было бы true, то выполнилось бы выражение f >= f - 68 >= 68, которое бы выдало true,
//                                                         и поскольку значение типа boolean нельзя поделить на значение типа int, из - за несовместимости типов, то и возникает ошибка компиляции.

//      2.8 6 - 2 > 3 && 12 * 12 <= 119
        a = 6; b = 2; c = 3; d = 12; e = 119;
        resBool = a - b > c && d * d <= e;     // false - в начале выполняются операции вычитания, умножения, затем сравнения, то есть 4 > 3 - true,
                                               // 144 <= 119 - false, а затем выполняется логическая операция "И" - &&, в которой если оба оператора не равны, получается false
                                               // true && false = false

//      2.9 true && false
        aBool = true; bBool = false;
        resBool = aBool && bBool;    // false - поскольку как и в предыдущем примере выполняется логическая операция "И" - &&,
                                     // в которой если оба оператора не равны, получается false. true && false = false
    }
}
